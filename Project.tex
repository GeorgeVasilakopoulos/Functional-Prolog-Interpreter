\documentclass[10pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{hyperref}
\setlength{\parindent}{0cm}


\usepackage[utf8]{inputenc}
\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{parskip}
\usepackage{enumitem}





\makeatletter
\newcommand*\bigcdot{\mathpalette\bigcdot@{.5}}
\newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}
\makeatother



\begin{document}



\begin{center}
    \huge{Αρχές Γλωσσών Προγραμματισμού}

    \LARGE{Εργασία 3}

    \textbf{\Large{Prolog Interpreter}}
\end{center}

\vspace{0.5cm}

Σκοπός της εργασίας αυτής είναι η υλοποίηση ενος απλουστευμένου διερμηνέα για την γλώσσα Prolog. Ο διερμηνέας αυτός θα υποστηρίζει δύο τρόπους λειτουργίας, οι οποίοι περιγράφονται αναλυτικά στη συνέχεια:


\begin{itemize}
    \item Top-Down Evaluation
    \item Bottom-Up (Naive) Evaluation
\end{itemize}


Τα προγράμματα τα οποία θα φορτώνονται στον διερμηνέα θα αποτελούνται απο το βασικότερο υποσύνολο της γλώσσας Prolog, δηλαδή θα περιλαμβάνουν μονο \textit{κανόνες} μεταξύ \textit{κατηγορημάτων}, στα οποία θα συμμετέχουν \textit{ελεύθερες μεταβλητές} και \textit{όροι}, πιθανώς με συναρτησιακά σύμβολα. Για παράδειγμα: 



\begin{verbatim}
                        sum(0,Y,Y).
                        sum(s(X),Y,Z) :- sum(X,s(Y),Z).
\end{verbatim}



Ο διερμηνέας, αφού διαβάσει ενα αρχείο πηγαίου κώδικα Prolog, θα δέχεται ερωτήματα απο τον χρήστη στα οποία θα απαντά είτε με \textit{true}/\textit{false}, είτε δίνοντας κάποια κατάλληλη ανάθεση των ελεύθερων μεταβλητών.\

Η εκπόνηση της εργασίας μπορεί να χωριστεί στα εξής λογικά μέρη:

\subsection*{Parser (30\%)}

% Kαλείστε να υλοποιήσετε έναν parser για την Prolog, όμοιο με αυτόν που σας δίνεται.\
Σε πρώτη φάση, καλείστε να υλοποιήσετε εναν parser για την Prolog, ο οποίος θα δέχεται σαν είσοδο ένα string (τα περιεχόμενα ενός αρχείου) και θα επιστρέφει για κάθε σωστή, συντακτικά, περίπτωση το ενδιάμεσο representation, όπως παρουσιάζεται παρακάτω.\

Στις περιπτώσεις όπου υπάρχει συντακτικό λάθος δεν χρειάζεται να το χειρίζεστε με συγκεκριμένο τρόπο, απλώς πρέπει αυτό να αναγνωρίζεται από τον κώδικα σας ώστε να μην συνεχίσει η εκτέλεση.\ 

Παρακάτω ακολουθεί η context-free grammar σε BNF η οποία περιγράφει την γλώσσα της Prolog που θα κάνετε parse:


\begin{verbatim}
                <Program> ::= <StmtList>

                <StmtList> ::= <Statement> <StmtList>
                             | ""
                                  
                <Statement> ::= <Predicate> "."
                              | <Predicate> ":-" <PredList> "."
                           
                <PredList> ::= <Predicate> <PredList2>

                <PredList2> ::= "," <Predicate> <PredList2>
                              | ""
                     
                <Predicate> ::= <Atom> "(" <TermList> ")"
                              | <Atom>
                        
                <TermList> ::= <Term> <TermList2>
\end{verbatim}
\begin{verbatim}
                <TermList2> ::= "," <Term> <TermList2>
                              | ""
                        
                <Term> ::= <Variable>
                         | <Predicate>
                    
                <Atom> ::= "[a-z][a-zA-Z0-9]*"
                         | <Integer>

                <Variable> ::= "[a-zA-Z][a-zA-Z0-9]*"

                <Integer> ::= "[1-9][0-9]*"
                            | 0
\end{verbatim}





H έξοδος του parser είναι ένα Abstract Syntax Tree του εκάστοτε αρχείου που δόθηκε ως είσοδος. To AST, είναι μία λίστα από ASTNode, ένα για κάθε statement του προγράμματος, ενω το ASTNode εμπίπτει στους εξής συντατικούς κανόνες της Haskell \footnote{Δεν είναι υποχρεωτικό να ακολουθήσετε τη συγκεκριμένη αναπαράσταση. Αυτή δίνεται για δική σας ευχέρεια.}:

\begin{verbatim}
                    data ASTNode
                        |   Fact ASTNode
                        |   Rule ASTNode [ASTNode]
                        |   Predicate String [ASTNode]
                        |   PredVariable String
\end{verbatim}

\begin{itemize}

\item Facts είναι τα clauses της μορφής "\textit{predicate} ." ενώ τα Rules έχουν την μορφή\\


\textit{predicate}  :- \textit{predicate}, \textit{predicate}, ..., \textit{predicate}.\\ 



Στην περίπτωση του Fact, το ASTNode που αντιστοιχεί είναι αυτό που παράγει το Predicate. 

Στην περίπτωση του Rule, το πρώτο ASTNode είναι το head predicate και η λίστα είναι όλα τα predicates που βρίσκονται στο tail του clause.

\item Κάθε predicate αποτελείται απο ένα string του ονόματος του και με μια λίστα από Predicates ή Variables, η οποία προφανώς μπορεί να είναι κενή.

\item Τα Variables είναι τα strings που ξεκινάνε με κεφαλαίο γράμμα και περιγράφονται ως "PredVariable String".

\end{itemize}

Για παράδειγμα, για το ακόλουθο πρόγραμμα:


\begin{verbatim}
                a(X) :- a(s(X)), b(Y).
                b(15).
\end{verbatim}

Το ενδιάμεσο representation θα είναι:

\begin{verbatim}
                [
                    Rule (PredVariable "X") [
                        Predicate "a" [
                            Predicate "s" [PredVariable "X"]
                        ],
                        Predicate "b" [
                            PredVariable "Y"
                        ]
                    ],
                    Fact (Predicate "15" [])
                ]

\end{verbatim}



\subsection*{Pattern Matching Algorithm (40\%)}

Οι αλγόριθμοι εξαγωγής συμπερασμάτων Top-Down και Bottom-Up βασίζονται σε έναν μηχανισμό σύγκρισης εκφράσεων. Για παράδειγμα, στο απλό πρόγραμμα:

\begin{verbatim}
                                    p(s(s(X)),Y).
\end{verbatim}

Προκειμένου να απαντηθεί το ερώτημα \verb|?- p(s(s(0)),1)| πρέπει να συγκριθούν οι δυο εκφράσεις, ώστε να αποφασιστεί εαν μπορούν να \textit{ταιριάξουν}, δηλαδή εαν υπάρχει κάποια αντικατάσταση των ελέυθερων μεταβλητών, ώστε οι δύο εκφράσεις να ταυτίζονται. \

Επομένως, ενα βασικό κομμάτι της υλοποίησης θα πρέπει να μοντελοποιεί την έννοια της \textit{αντικατάστασης} σε μια έκφραση, όπως και την έννοια του \textit{πιο γενικού ενοποιτή} (Most General Unifier) μεταξύ δύο ή περισσοτέρων εκφράσεων.

Ο πιο γενικός ενοποιητής μεταξύ δύο ή παραπάνω εκφράσεων είναι η αντικατάσταση η οποία:
\begin{itemize}
    \item Εαν εφαρμοστεί επι των εκφράσεων, τότε αυτές θα ταυτιστούν μεταξύ τους 
    \item Είναι η πιο \textit{γενική} αντικατάσταση με αυτή την ιδιότητα
\end{itemize}

Έχοντας αυτά υπ'όψιν, καλείστε να υλοποιήσετε μια συνάρτηση η οποία θα δέχεται δύο \textit{εκφράσεις} και  θα επιστρέφει τον \textit{πιο γενικό ενοποιτή} τους.\

Στην πορεία πιθανώς να χρειαστεί να υλοποιήσετε και άλλες 'πράξεις' μεταξύ \textit{αντικαταστάσεων} και \textit{εκφράσεων}, όπως εφαρμογή αντικατάστασης σε έκφραση και σύνθεση αντικαταστάσεων.


\subsection*{Top-Down Evaluation (30\%)}

Η αποτίμηση Top-Down είναι ένας αναδρομικός αλγόριθμος ο οποίος προσπαθεί να αναγάγει ένα ερώτημα σε γνωστά facts, χρησιμοποιώντας τους κανόνες. By default, οι περισσότεροι Prolog interpreters λειτουργούν σύμφωνα με αυτή την τεχνική.\

Συγκεκριμένα, όταν η αποτίμηση Top-Down δέχεται ένα \textbf{ικανοποιήσιμο} ερώτημα, τότε επιστρέφει μια ανάθεση των ελέυθερων μεταβλητών για την οποία το ερώτημα ικανοποιείται. H ανάθεση αυτή μπορεί να είναι και 'κενή' για ενα ικανοποιήσιμο ερώτημα.\


Αντίθετα, όταν η αποτίμηση Top-Down δέχεται ενα \textbf{μη ικανοποιήσιμο} ερώτημα, τότε επιστρέφει οτι δεν υπάρχει κάποια κατάλληλη ανάθεση.\

Συνοπτικά, η διαδικασία αποτίμησης λειτουργεί ως εξής:\

\begin{itemize}
    \item Για ένα δωθέν ερώτημα, ελέγχεται εαν αυτό μπορεί να ταιριάξει με την \textit{κεφαλή} κάποιου κανόνα.\
    \item Εάν βρεθεί \textit{κεφαλή} κανόνα που ταιριάζει, τότε εφαρμόζεται η αντίστοιχη ανάθεση στην \textit{ουρά} του κανόνα.\

    Έπειτα, για κάθε κατηγόρημα της ουράς, σειριακά, καλείται αναδρομικά η διαδικασία αποτίμησης και οι αναθέσεις που προκύπτουν εφαρμόζονται στα κατηγορήματα που ακολουθούν.\

    Εαν βρεθεί ανάθεση για όλα τα κατηγορήματα του κανόνα, τοτε το ερώτημα είναι ικανοποιήσιμο και η τελική ανάθεση προκύπτει απο τη \textbf{σύνθεση} των επί μέρους αναθέσεων.

    Εαν κάποια αναδρομική κλήση δεν επιστρέψει ανάθεση, τότε το αρχικό ερώτημα δεν μπορεί να ικανοποιηθεί βάσει του συγκεκριμένου κανόνα και αναζητείται άλλος κανόνας.\

    \item Εάν τελικά δεν βρεθεί τέτοιος κανόνας, τότε το ερώτημα είναι μη ικανοποιήσιμο. 

\end{itemize}

Να σημειωθεί οτι η σειρά με την οποία ελέγχονται οι κανόνες μπορεί να επηρεάσει καθοριστικά την εκτέλεση. Για τον λόγο αυτό, η σειρά ελέγχου θα είναι «απο πάνω προς τα κάτω», κατα σύμβαση.\

Αφού υλοποιήσετε τον αλγόριθμο ώστε να βρίσκει την πρώτη ανάθεση κατά σειρά, δοκιμάστε να τον επεκτείνετε ώστε να μπορεί να συνεχίσει την αναζήτηση, κατ'επιλογή του χρήστη \footnote{Εδω θα χρειαστεί να χειριστείτε είσοδο-έξοδο}, κάνοντας backtrack, όμοια με τον swipl interpreter που έχουμε δεί στο μάθημα.\



\subsection*{Bottom-Up Evaluation (Bonus 30\%)}

H αποτίμηση Bottom-Up είναι ένας επαναληπτικός αλγόριθμος ο οποίος σε κάθε βήμα διευρύνει το σύνολο των facts, βάσει των ήδη γνωστών facts.\

Σε κάθε επανάληψη, για κάθε κανόνα επιλέγονται όλα τα facts που ταιριάζουν στην ουρά και η αντίστοιχη \textit{ενοποιημένη} κεφαλή προστίθεται ως fact σε όλες τις επόμενες επαναλήψεις.\

Η διαδικασία αυτη θα τερματίσει εαν σε κάποια επανάληψη δεν προστεθούν νεα facts στο σύνολο.\

Ωστόσο, υπάρχουν προγράμματα Prolog τα οποία παράγουν καινούργια facts σε κάθε επανάληψη, με αποτέλεσμα αυτή η διαδικασία να μην τερματίζει ποτέ.\


Παράδειγμα 1:
\begin{verbatim}
                    p(s(s(s(0)))).
                    p(Χ) :- p(s(Χ)).
\end{verbatim}

Εκτέλεση:
\begin{verbatim}
                    S = { p(s(s(s(0)))) }
                    S = { p(s(s(s(0)))), p(s(s(0))) }
                    S = { p(s(s(s(0)))), p(s(s(0))), p(s(0)) }
                    S = { p(s(s(s(0)))), p(s(s(0))), p(s(0)) p(0) }
\end{verbatim}

Μετά την τέταρτη επανάληψη δεν θα προστεθεί κανένα νεο fact στο σύνολο \verb|S|, αρα ο αλγόριθμος θα τερματίσει.





Παράδειγμα 2:
\begin{verbatim}
                    p(X, Y) :- q(s(X)), q(Y).
                    q(X) :- q(s(X)).
                    q(s(s(0))).
\end{verbatim}

Εκτέλεση:
\begin{verbatim}
                    S = { q(s(s(0))) }
                    S = { ... , q(s(0)) }
                    S = { ... , q(0) }
                    S = { ... , p(0,0) }
\end{verbatim}

Όμοια εδώ, μετά την 4η επανάληψη ο αλγόριθμος τερματίζει.




Παράδειγμα 3:
\begin{verbatim}
                    p(s(X)) :- p(X).
                    p(0).
\end{verbatim}

Εκτέλεση:
\begin{verbatim}
                    S = { p(0) }
                    S = { ... , p(s(0)) }
                    S = { ... , p(s(s(0))) }
                    S = { ... , p(s(s(s(0)))) }
                    ...
\end{verbatim}

Εδω ο αλγόριθμος δεν τερματίζει.

\subsection*{Παραδοτέο}

Για κάθε ενα απο τα μέρη της εργασίας, υλοποιήστε ενα αντίστοιχο πηγαίο πρόγραμμα Haskell με τις σχετικές συναρτήσεις. \

Να συμπεριλάβετε και ενα \verb|main.hs| αρχείο το οποίο να υλοποιεί ενα στοιχειώδες User Interface για τον interpreter.\

Φροντίστε το πρόγραμμά σας να μεταγλωττίζεται με τον Glasgow Haskell Compiler (ghc) και δημιουργήστε και ενα Makefile.\

Στην εργασία αυτή απαγορεύεται η χρήση external modules της Haskell.\

Η εργασία μπορεί να υλοποιηθεί είτε ατομικά, είτε από ομάδες των δύο ατόμων.\

Επιπλέον, περιγράψτε συνοπτικά τις όποιες σχεδιαστικές επιλογές σας σε ενα README.\

Για οποιαδήποτε περαιτέρω διευκρίνηση, μπορείτε να απευθυνθείτε μέσω email στον διδάσκοντα του μαθήματος, ή σε κάποιον απο τους συνεργάτες, στις παρακάτω διευθύνσεις:

\begin{verbatim}
                        prondo [at] di.uoa.gr - Παναγιώτης Ροντογιάννης
                    sdi2000018 [at] di.uoa.gr - Γιώργος Βασιλακόπουλος
                    sdi2000232 [at] di.uoa.gr - Μιχάλης Βιταντζάκης
                    sdi1700065 [at] di.uoa.gr - Δημήτρης Κωσταντινίδης
\end{verbatim}





\end{document}
