\documentclass[10pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{hyperref}
\setlength{\parindent}{0cm}


\usepackage[utf8]{inputenc}
\usepackage[greek,english]{babel}
\usepackage{alphabeta}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{parskip}
\usepackage{enumitem}





\makeatletter
\newcommand*\bigcdot{\mathpalette\bigcdot@{.5}}
\newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}
\makeatother



\begin{document}

TODO: Προθεσμία, κατανομή μονάδων...


\begin{center}
    \huge{Αρχές Γλωσσών Προγραμματισμού}

    \LARGE{Εργασία 3}

    \textbf{\Large{Prolog Interpreter}}
\end{center}

\vspace{0.5cm}

Σκοπός της εργασίας αυτής είναι η υλοποίηση ενος απλουστευμένου διερμηνέα για την γλώσσα Prolog. Ο διερμηνέας αυτός θα υποστηρίζει δύο τρόπους λειτουργίας, οι οποίοι περιγράφονται αναλυτικά στη συνέχεια:


\begin{itemize}
    \item Top-Down Evaluation
    \item Bottom-Up (Naive) Evaluation
\end{itemize}


Τα προγράμματα τα οποία θα φορτώνονται στον διερμηνέα θα αποτελούνται απο το βασικότερο υποσύνολο της γλώσσας Prolog, δηλαδή θα περιλαμβάνουν μονο \textit{κανόνες} μεταξύ \textit{κατηγορημάτων}, στα οποία θα συμμετέχουν \textit{ελεύθερες μεταβλητές} και \textit{όροι}, πιθανώς με συναρτησιακά σύμβολα. Για παράδειγμα: 



\begin{verbatim}
                        sum(0,Y,Y).
                        sum(s(X),Y,Z) :- sum(X,s(Y),Z).
\end{verbatim}



Ο διερμηνέας, αφού διαβάσει ενα αρχείο πηγαίου κώδικα Prolog, θα δέχεται ερωτήματα απο τον χρήστη στα οποία θα απαντά είτε με \textit{true}/\textit{false}, είτε δίνοντας κάποια κατάλληλη ανάθεση των ελεύθερων μεταβλητών.\\
\\
Η εκπόνηση της εργασίας μπορεί να χωριστεί στα εξής λογικά μέρη:\\
\\
\textbf{Prolog Parser (Bonus ? \% )}

Σαν bonus ερώτημα καλείστε να υλοποιήσετε έναν parser για την Prolog, όμοιο με αυτόν που σας δίνεται.\\
\\
Ο parser σας θα δέχεται σαν είσοδο ένα string και θα επιστρέφει για κάθε σωστή, συντακτικά, περίπτωση το ενδιάμεσο representation, όπως παρουσιάστηκε παραπάνω. Στις περιπτώσεις όπου υπάρχει συντακτικό λάθος δεν χρειάζεται να το χειρίζεστε με συγκεκριμένο τρόπο, απλώς πρέπει αυτό να αναγνωρίζεται από τον κώδικα σας ώστε να μην συνεχίσει η εκτέλεση. Για την υλοποίηση απαγορεύεται η χρήση extra modules της Haskell. Παρακάτω ακολουθεί η context-free grammar σε BNF η οποία περιγράφει την γλώσσα της prolog που θα κάνετε parse:


\begin{verbatim}
                <Program> ::= <StmtList>

                <StmtList> ::= <Statement> <StmtList>
                         | ""
                                  
                <Statement> ::= <Predicate> "."
                          | <Predicate> ":-" <PredList> "."
                           
                <PredList> ::= <Predicate> <PredList2>

                <PredList2> ::= "," <Predicate> <PredList2>
                          | ""
                     
                <Predicate> ::= <Atom> "(" <TermList> ")"
                          | <Atom>
                        
                <TermList> ::= <Term> <TermList2>

                <TermList2> ::= "," <Term> <TermList2>
                          | ""
                        
                <Term> ::= <Variable>
                     | <Predicate>
                    
                <Atom> ::= "[a-z][a-zA-Z0-9]*"
                     | <Integer>

                <Variable> ::= "[a-zA-Z][a-zA-Z0-9]*"

                <Integer> ::= [1-9][0-9]*
                        | 0
\end{verbatim}





H έξοδος του parser είναι ένα Abstract Syntax Tree του εκάστοτε αρχείου που δόθηκε ως είσοδος. To AST, είναι μία λίστα από ASTNode, ένα για κάθε statement του προγράμματος, ενω το ASTNode εμπίπτει στους εξής συντατικούς κανόνες:
\begin{verbatim}
                    data ASTNode
                        |   Fact ASTNode
                        |   Rule ASTNode [ASTNode]
                        |   Predicate String [ASTNode]
                        |   PredVariable String
\end{verbatim}

\begin{itemize}

\item Facts είναι τα clauses της μορφής "\textit{predicate} ." ενώ τα Rules έχουν την μορφή\\


\textit{predicate}  :- \textit{predicate}, \textit{predicate}, ..., \textit{predicate}.\\ 



Στην περίπτωση του Fact, το ASTNode που αντιστοιχεί είναι αυτό που παράγει το Predicate. Στην περίπτωση του Rule, το πρώτο ASTNode είναι το head predicate και η λίστα είναι όλα τα predicates που βρίσκονται στο tail του clause.

\item Κάθε predicate αντιστοιχεί με ένα string. το identifier του (το οποίο βολικά μπορεί να είναι και αριθμός) και με μια λίστα από Predicates ή Variables η οποία προφανώς μπορεί να είναι κενή.

\item Τα Variables είναι τα strings που ξεκινάνε με κεφαλαίο γράμμα και περιγράφονται ως "PredVariable String".

\end{itemize}

Για παράδειγμα, για το ακόλουθο πρόγραμμα:


\begin{verbatim}
                a(X) :- a(s(X)), b(Y).
                b(15).
\end{verbatim}

Το ενδιάμεσο representation θα είναι:

\begin{verbatim}
                [
                    Rule (PredVariable "X") [
                        Predicate "a" [
                            Predicate "s" [PredVariable "X"]
                        ],
                        Predicate "b" [
                            PredVariable "Y"
                        ]
                    ],
                    Fact (Predicate "15" [])
                ]

\end{verbatim}



\textbf{Pattern Matching Algorithm ( ? \% )}

Οι αλγόριθμοι εξαγωγής συμπερασμάτων Top-Down και Bottom-Up βασίζονται σε έναν μηχανισμό σύγκρισης εκφράσεων. Για παράδειγμα, στο απλό πρόγραμμα:

\begin{verbatim}
                                    p(s(s(X)),Y).
\end{verbatim}

Προκειμένου να απαντηθεί το ερώτημα \verb|?- p(s(s(0)),1)| πρέπει να συγκριθούν οι δυο εκφράσεις, ώστε να αποφασιστεί εαν μπορούν να \textit{ταιριάξουν}, δηλαδή εαν υπάρχει κάποια αντικατάσταση των ελέυθερων μεταβλητών, ώστε οι δύο εκφράσεις να ταυτίζονται. \\
\\
Επομένως, ενα βασικό κομμάτι της υλοποίησης θα πρέπει να μοντελοποιεί την έννοια της \textit{αντικατάστασης} σε μια έκφραση, όπως και την έννοια του \textit{πιο γενικού εννοποιτή} (Most General Unifier) μεταξύ δύο ή περισσοτέρων εκφράσεων.

Ο πιο γενικός ενοποιητής μεταξύ δύο ή παραπάνω εκφράσεων ορίζεται ως η αντικατάσταση η οποία:
\begin{itemize}
    \item Εαν εφαρμοστεί επι των εκφράσεων, τότε αυτές θα ταυτίζονται 
    \item Εαν μια άλλη έκφραση ταιριάζει με όλες τις αρχικές, τότε θα ταιριάζει και με την \textit{εννοποιημένη} έκφραση.
\end{itemize}


\textbf{Top-Down (? \% )}

Ο Top-Down αλγόριθμος είναι αναδρομικός αλγόριθμος ο οποίος προσπαθεί να απαντήσει ένα ερώτημα ξεκινώντας από αυτό προσπαθώντας να φτάσει σε facts.
\\
Συγκεκριμμένα ο αλγόριθμος παίρνει σαν είσοδο ένα ερώτημα και αρχικά προσπαθεί να βρει ποιες προτάσεις που μπορούν να ταιριάξουν στο ερώτημα.
\\
Αν ταιριάξει με κάποιο fact τότε το ερώτημα είναι αληθές και επιστρέφετε το ερώτημα αφού πρώτα γίνει η εννοποίηση.
\\
Αν ταιριάζει με κάποιο head μιας πρότασης τότε χρησιμοποιείτε αναδρομικά ο αλγόριθμος για να ελεγχθεί αν είναι true κάθε όρος του tail της πρότασης ενώ παράλληλα γίνονται όσες ενωποιήσεις χρειάζονται. Αν κάθε όρος του tail είναι αληθής τότε το ερώτημα είναι αληθής και επιστρέφετε μετά από τις αναθέσεις που έγιναν στις ενωποιήσεις.
\\ 
Επειδή η σειρά που θα ελέγξει ο αλγόριθμος τις προτάσεις και τους όρους παίζει ρόλο στο τελικό αποτέλεσμα, γίνονται οι υποθέσεις ότι ο αλγόριθμος ελέγχει τις προτάσεις πάνω προς τα κάτω και τους όρους των tail από αριστερά προς τα δεξιά.


Για παράδειγμα έστω το παρακάτω πρόγραμμα:
\begin{verbatim}
                    p(X, Y) :- q(s(X)), q(Y).
                    q(s(s(0))).
                    q(X) :- q(s(X)).
\end{verbatim}

Ο αλγόριθμος για ερώτημα $q(X)$ θα επιστρέψει $q(s(s(0)))$ λόγο του fact $q(s(s(0))).$.

Για ερώτημα $q(0)$ ο αλγόριθμος θα δει ότι είναι ενωποιήσιμη με το head της τρίτης πρότασης και θα προσπαθήσει να αποδείξει το $q(s(0))$. Ομοίως λόγο της τρίτης πρότασης θα προσπαθήσει να αποδείξει το $q(s(s(0)))$. Λόγο της πεύτερης πρότασης θα το καταφέρει άρα αναδρομικά θα επιστραφεί το $q(0)$ ως αληθές.

Για ερώτημα $p(s(X),Y)$ ο αλγόριθμος λόγο της πρώτης πρότασης θα προσπαθήσει πρώτα να αποδείξει το $q(s(s(X)))$, που θα τα καταφέρει θέτοντας $X = 0$ χρησιμοποιώντας το fact της δεύτερης γραμμής, και έπειτα θα προσπαθήσει να αποδείξει το $q(Y)$, που θα τα καταφέρει θέτοντας $Y = s(s(0))$. Άρα ο αλγόριθμος θα επιστρέψει το $p(s(0),s(s(0))$ ως αληθές.

Για το ερώτημα $p(s(s(s(0))))$ ο αλγόριθμος θα χρησιμοποιεί την πρώτη πρόταση συνεχώς αυξάνοντας τον αριθμό των $s$ και δεν θα σταματήσει.

\textbf{Bottom-Up (? \% )}

O Bottom-Up αλγόριθμος είναι ένας επαναληπτικός αλγόριθμος ο οποίος σε κάθε βήμα διευρύνει το σύνολο των facts, βάσει των ήδη γνωστών facts.\\
\\
Σε κάθε επανάληψη, για κάθε κανόνα επιλέγονται όλα τα facts που ταιριάζουν στο tail και το αντίστοιχο \textit{ενοποιημένο} head προστίθεται ως fact σε όλες τις επόμενες επαναλήψεις.   
\\
Η διαδικασία αυτη θα τερματίσει εαν σε κάποια επανάληψη δεν προστεθούν νεα facts στο σύνολο.\\
\\
Όμως, υπάρχουν προγράμματα Prolog τα οποία παράγουν καινούργια facts σε κάθε επανάληψη με αποτέλεσμα αυτή η διαδικασία να μην τερματίζει ποτέ. 

Για παράδειγμα, ο επαναληπτικός αλγόριθμος για το ακόλουθο πρόγραμμα θα τρέξει ως εξής:


Πρόγραμμα 1:
\begin{verbatim}
                    p(s(s(s(0)))).
                    p(x) :- p(s(x)).
\end{verbatim}

Εκτέλεση:
\begin{verbatim}
                    S = { p(s(s(s(0)))) }
                    S = { p(s(s(s(0)))), p(s(s(0))) }
                    S = { p(s(s(s(0)))), p(s(s(0))), p(s(0)) }
                    S = { p(s(s(s(0)))), p(s(s(0))), p(s(0)) p(0) }
\end{verbatim}

Μετά την τέταρτη επανάληψη δεν θα προστεθεί κανένα νεο fact στο σύνολο \verb|S|, αρα ο αλγόριθμος θα τερματίσει.





Πρόγραμμα 2:
\begin{verbatim}
                    p(X, Y) :- q(s(X)), q(Y).
                    q(X) :- q(s(X)).
                    q(s(s(0))).
\end{verbatim}

Εκτέλεση:
\begin{verbatim}
                    S = { q(s(s(0))) }
                    S = { ... , q(s(0)) }
                    S = { ... , q(0) }
                    S = { ... , p(0,0) }
\end{verbatim}

Όμοια εδώ, μετά την 4η επανάληψη ο αλγόριθμος τερματίζει.




Πρόγραμμα 3:
\begin{verbatim}
                    p(s(X)) :- p(X).
                    p(0).
\end{verbatim}

Εκτέλεση:
\begin{verbatim}
                    S = { p(0) }
                    S = { ... , p(s(0)) }
                    S = { ... , p(s(s(0))) }
                    S = { ... , p(s(s(s(0)))) }
                    ...
\end{verbatim}

Εδω ο αλγόριθμος δεν τερματίζει.

% Συγκεκριμμένα κάθε μορφή του προγράμματος θα περιέχει είτε ένα fact της μορφής $str(x_1, \dotsc, x_n).$ είτε έναν κανόνα της μορφής $str_0(x_1,\dotsc, x_{n_0}) :- str_1(y_1,\dotsc, y_{n_1}), \dotsc, str_m(y_1,\dotsc, y_{n_m}).$ όπου $str_i$ συμβολοσειρές και $x_i$, $y_i$, $z_i$ όροι. Οι όροι μπορεί να είναι μεταβλητές, δηλαδή συμβολοσειρές που έχουν κεφαλαίο το πρώτο γράμμα, σταθερές, δηλαδή συμβολοσειρές που δεν είναι μεταβλητές, ή συναρτισιακά σύμβολα της μορφής $str(x_1, \dotsc, x_n)$  όπου $str$ συμβολοσειρά και $x_i$ όροι.


% Η υλοποίηση του bottom-up διερμηνέα γίνεται με τα εξής βήματα:
% \begin{itemize}
%     \item Λεξική και συντακτική ανάληση: Σε αυτή την φάση γίνεται ο έλεγχος του προγράμματος για συντακτικά λάθη και η μετατροπή του σε συντακτικό δέντρο(AST) για να μπορεί να αναλυθεί από τα επόμενα βήματα. Για την διευκόλυνση σας, σας δίνεται έτοιμος κώδικας που κάνει αυτήν την μετατροπή
%     \item Υπολογισμός του ελάχιστου μοντέλου του προγράμματος: Άτυπα ελάχιστο μοντέλο $M_P$ ενώς λογικού προγράμματος $P$ είναι το σύνολο $Μ_P \{A | P \models A\}$ όπου $P \models A$  ουσιαστικά συμαίνει ότι το $A$ μπορεί να αποδειχθεί από το $P$.
%     \item Επιστροφή απαντήσεων: Επειδή το $M_p$ περιέχει το $A$ αν και μόνο αν μπορεί να αποδειχθεί από το $P$, για να απαντηθεί κάθε ερώτηση $Q$ αρκεί να ελεγχθεί αν $Q \in M_P$. Αν ανήκει τότε το $Q$ είναι αληθές σύμφωνα με το $P$ και η απάντηση πρέπει να είναι "True" μαζί με το $Q$ αφού γίνουν όσες αναθέσεις μεταβλητών χρειάζονται, διαφορετικά η απάντηση είναι "False". 
% \end{itemize}

% \section*{Υπολογισμός Ελάχιστου Μοντέλου}

% Έστω λογικό πρόγραμμα $P$, ο υπολογισμός του $M_P$ θα γίνει με την βοήθεια της συνάρτησης $T_P(i)$, $i \in \mathbb{N}$. Διαισθητικά το $T_P(i)$ είναι το σύνολο των κατηγορημάτων που μπορούν να αποδειχθούν από το $P$ σε $i$ βήματα και ορίζετε ως:
% \[
%     T_P(i) =
%     \begin{cases}
%         \{F| \text{F is a fact in P}\},\ i = 1\\
%         T_P(i) = T_P(i-1) \cup \{H | H :- T_1, \dotsc, T_n \in P \land  T_1, \dotsc, T_n \in T_P(i-1)\},\ i > 1
%     \end{cases}
% \]

% Ισχύει ότι αν $T_P(i-1) = T_P(i)$ τότε $T_P(i) = M_P$.

% Για την εύρεση του $T_P$ θα χρησιμοποιηθούν οι εξής δύο αλγόριθμοι: naive και semi-naive.

% \subsection*{Naive Algorithm}

% Ο naive αλγόριθμος υπολογίζει το $M_P$ υπολογίζοντας το $T_P$  σύμφωνα με τον ορισμό του.

% Αρχικοποιείτε μία λίστα με τα facts του προγράμματος. 

% Σε κάθε επανάλληψη ελέγχετε κάθε πρόταση του λογικού προγράμματος. Αν κάθε τμήμα της ουράς, δηλαδή ότι βρίσκετε μετά το ":-", υπάρχει ήδη στην λίστα τότε εισάγετε, αν δεν υπάρχει, η κεφαλή στην λίστα. Η επανάληψη τελειώνει όταν δεν εισάγωνται νέα στοιχεία στην λίστα.

% \subsection*{Semi-Naive Algorithm}

% Ο αλγόριθμος semi-naive είναι μία παραλλαγή του naive αλγόριθμου που χρησιμοποιεί λιγότερο χώρο. 

% Σε κάθε επανάλληψη ο αλγόριθμος αντί να εισάγει τα κατηγορίματα στην λίστα της προηγούμρνης επανάλληψης δημηοθργεί μία καινούργια λίστα και τοποθετούνται εκεί.


\end{document}
